#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : require

#include "../include/set_bindings.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = GLOBAL_SET, binding = GLOBAL_BINDING_STORAGE_IMAGE) uniform writeonly image2D storageImages[];
layout(set = GLOBAL_SET, binding = GLOBAL_BINDING_COMBINED_SAMPLER) uniform sampler2D combinedSamplers[];

layout(push_constant) uniform PC {
	float brightness;
	float saturation;
	float contrast;
	float pad0;
	uint cmbViewIdx;
	uint sampledViewIdx;
	uint pad1[2];
} pc;

void main() {
	uvec2 texelCoord = gl_GlobalInvocationID.xy;

	ivec2 size = imageSize(storageImages[nonuniformEXT(pc.sampledViewIdx)]);
	if (texelCoord.x >= uint(size.x) || texelCoord.y >= uint(size.y)) return;

	vec2 uv = vec2(texelCoord) / vec2(size);

	vec4 color = texture(combinedSamplers[nonuniformEXT(pc.cmbViewIdx)], uv);

	color.rgb *= pc.brightness;
	color.rgb = clamp(color.rgb, 0.0, 1.0);
	color.rgb = pow(color.rgb, vec3(0.8)); // Adjust tone

	float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
	color.rgb = mix(vec3(gray), color.rgb, pc.saturation);

	color.rgb = (color.rgb - 0.5) * pc.contrast + 0.5;

	imageStore(storageImages[nonuniformEXT(pc.sampledViewIdx)], ivec2(texelCoord), color);
}