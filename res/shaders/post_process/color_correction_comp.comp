#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 3, rgba16f) uniform writeonly image2D storageImages[];
layout(set = 0, binding = 4) uniform sampler2D combinedSamplers[];

layout(push_constant) uniform PC {
    float brightness;
    float saturation;
    float contrast;
    float pad0;
    uint cmbViewIdx;
    uint sampledViewIdx;
    uint pad1[2];
} pc;

vec3 toneMapFilmicUnreal(vec3 x) {
    const float A = 0.15;
    const float B = 0.50;
    const float C = 0.10;
    const float D = 0.20;
    const float E = 0.02;
    const float F = 0.30;
    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F)) - E/F;
}

vec3 toneMap(vec3 color) {
    color = toneMapFilmicUnreal(color * pc.brightness);
    color = clamp(color / toneMapFilmicUnreal(vec3(11.2)), 0.0, 1.0);
    return color;
}

void main() {
    uvec2 texelCoord = gl_GlobalInvocationID.xy;

    ivec2 size = imageSize(storageImages[nonuniformEXT(pc.sampledViewIdx)]);
    if (texelCoord.x >= uint(size.x) || texelCoord.y >= uint(size.y)) return;

    vec2 uv = vec2(texelCoord) / vec2(size);

    vec4 color = texture(combinedSamplers[nonuniformEXT(pc.cmbViewIdx)], uv);

    color.rgb *= pc.brightness;
    color.rgb = clamp(color.rgb, 0.0, 1.0);
    color.rgb = pow(color.rgb, vec3(0.8)); // Adjust tone

    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
    color.rgb = mix(vec3(gray), color.rgb, pc.saturation);

    color.rgb = (color.rgb - 0.5) * pc.contrast + 0.5;

    //color.rgb = toneMap(color.rgb);

    imageStore(storageImages[nonuniformEXT(pc.sampledViewIdx)], ivec2(texelCoord), color);
}