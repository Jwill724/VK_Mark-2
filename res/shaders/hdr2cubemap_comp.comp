#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D equirectMap;
layout(binding = 1, rgba16f) uniform writeonly image2DArray cubeMap;

layout(push_constant) uniform PC {
    int resolution;   // cube face size
    int pad[3];
} pc;

const float PI = 3.14159265358979323846;

// map workgroup Z to cube face index 0..5
int face() {
    return int(gl_WorkGroupID.z);
}

// build a direction vector for a given cube face + uv
vec3 dirForFace(int f, vec2 uv) {
    // uv in [0,1], remap to [-1,1]
    vec2 xy = uv * 2.0 - 1.0;
    if (f == 0) return normalize(vec3( 1,   -xy.y,   -xy.x)); // +X
    if (f == 1) return normalize(vec3(-1,   -xy.y,    xy.x)); // -X
    if (f == 2) return normalize(vec3( xy.x,  1,      xy.y)); // +Y
    if (f == 3) return normalize(vec3( xy.x, -1,     -xy.y)); // -Y
    if (f == 4) return normalize(vec3( xy.x, -xy.y,   1));   // +Z
                    return normalize(vec3(-xy.x, -xy.y,  -1));  // -Z
}

void main() {
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    if (px.x >= pc.resolution || px.y >= pc.resolution) {
        return;
    }

    // normalized [0,1] uv inside this face
    vec2 uv = (vec2(px) + 0.5) / float(pc.resolution);
    int f = face();
    vec3 d = dirForFace(f, uv);

    // convert direction to equirectangular (lat/long) uv
    float theta = atan(d.z, d.x);
    float phi   = asin(clamp(d.y, -1.0, 1.0));
    vec2 eUV;
    eUV.x = theta * (1.0 / (2.0 * PI)) + 0.5;
    eUV.y = phi   * (1.0 / PI)         + 0.5;

    float u = (phi / (2.0 * PI)) + 0.5;
    float v = (theta / PI) + 0.5;

    vec3 c = texture(equirectMap, eUV).rgb;
    imageStore(cubeMap, ivec3(px, f), vec4(c, 1.0));
}